function ShowDotbrackets(signs) {	var sign = new Array();	for ( n=0 ; n<signs.length ; ++n )	{		sign[n] = signs.substring(n,n+1);	}	var w=12;  // Width of every element.	var h=2*w; // Height of every element.	// Bagin, How many cols in earch row. 	var cols;	var width;	width = $('#div_svgDB').width();	//alert(width);	cols = parseInt( width / w ) - 2;	// End, How many cols in earch row.	var rows = Math.ceil(signs.length/cols); // How many rows for the signs.	var row=0; //	var col=0; //	var xi=0; // position of every element.	var yi=0; // position of every element.	var svgDoc=document.getElementById("svgDB");	// Set attribute width & height of svgDB.	svgDoc.setAttributeNS( null, "width", (cols)*w+10 );	svgDoc.setAttributeNS( null, "height", (rows)*h );	for ( i=0 ; i<signs.length ; ++i )	{		row = Math.floor( i / cols );		col = i % cols;		xi = col * w;		yi = row * h;		// Draw the rects. Begin		var rect = document.getElementById("rect"+i);		if ( rect == null  )		{ // This object do not exixted.			var svgns = "http://www.w3.org/2000/svg";			var rect = document.createElementNS(svgns, "rect");			svgDoc.appendChild(rect);		}		rect.setAttributeNS( null, "id", "rect"+i );		rect.setAttributeNS( null, "index", i );		rect.setAttributeNS( null, "x", xi );		rect.setAttributeNS( null, "y", yi );		rect.setAttributeNS( null, "width", w-1 );		rect.setAttributeNS( null, "height", h-2 );		rect.setAttributeNS( null, "fill", "white" );		//rect.addEventListener("click", getIndex, false);		// Draw the rects. End		// Draw the signs. Begin		var text = document.getElementById("text"+i);		if ( text == null  )		{ // This object do not exixted.			var text = document.createElementNS(svgns, "text");			svgDoc.appendChild(text);		}		text.setAttributeNS(null, "id", "text"+i);		text.setAttributeNS(null, "index", i);		text.setAttributeNS(null, "x", 0.2*w+xi);		text.setAttributeNS(null, "y", 0.7*h+yi);		text.setAttributeNS(null, "fill", "black");		text.setAttributeNS(null, "font-size", "25");		text.setAttributeNS(null, "font-size", 0.8*h);		text.textContent = sign[i];		//text.addEventListener("click", getIndex, false);		text.addEventListener('click', 			function(event) {				getIndex(event, signs.length);			},		false);		// Draw the signs. End	} // for ( i=0 ; i<signs.length ; ++i )} // function ShowDotbrackets()function showSS(SecondStructure, id, gffData, ColorKey) {	var nextColorAvailable=0;	var numberOfDefaultColors=10;	var defaultColors=[];	defaultColors[0]="#FF0000"; //Red	//defaultColors[1]="#FFFF00"; //Yellow	defaultColors[1]="#7070db";	defaultColors[2]="#00FFFF"; //Teal	defaultColors[3]="#28FF28"; //Lime	defaultColors[4]="#FF00FF"; //Pink	defaultColors[5]="#FF9900"; //Orange	defaultColors[6]="#9999FF"; //Purple	defaultColors[7]="#00FF99"; //Seafoam	defaultColors[8]="#339900"; //Green	defaultColors[9]="#66CCFF"; //Baby Blue	var gffColorKey = {};	//gffColorKey["Unknown"]="#DDDDDD"; //Gray	//gffColorKey["Other"]="#808080"; //Darker Gray	gffColorKey["Other"]="#cccccc";	var nucleotideColorKey={};	nucleotideColorKey['A']="#FF0000";	//nucleotideColorKey['U']="#FFFF00";	nucleotideColorKey['U']="#ff9900";	nucleotideColorKey['G']="#00FFFF";	nucleotideColorKey['C']="#28FF28";	nucleotideColorKey['Default']="#DDDDDD";	var svgns = "http://www.w3.org/2000/svg";	var coordinates=SecondStructure.coordinate;	// It imply semicolon(";") in the coordinates. 	// That means the user use a semicolon(";") as separator.	if ( coordinates.indexOf(";")>=0 ){  		// Define separator as semicolon(";"). 		var separator=";"; 	}else{		// Define separator as space(" ").		var separator=" "; 	}	var xy = coordinates.split(separator);	var x = new Array();	var y = new Array();	var elements = new Array();	for ( var n=0 ; n<SecondStructure.sequence.length ; ++n ){		var coor = xy[n].split(",");		x[n] = coor[0]; 		y[n] = coor[1];		elements[n] = SecondStructure.sequence.substring(n,n+1);	}	var color = new Array();	// Fill the circle with a user defined color.	if( SecondStructure.color != undefined && false){		color = SecondStructure.color.split(separator);	}else{		// When user defined color does not exist,		// fill the circle with a default color.		// 'A': Red, 'U': Yellow, 'G': Blue, 'C': green.		var feature = '';		for ( var n=0; n<SecondStructure.sequence.length ; ++n ){			if(gffData == 'none'){				//Nucelotide Coloration				if(elements[n] in nucleotideColorKey){					color[n]=nucleotideColorKey[elements[n]];				}else{					color[n]=nucleotideColorKey["Default"];				}			}else{				//GFF Coloration				var gffRegion="";				var splitData = gffData.split("\n");				for(var i = 0; i < splitData.length; i++) {										var gffTabSplit=splitData[i].split("\t"); 					//position of the region					var start = gffTabSplit[3] - 1;					var end = gffTabSplit[4] - 1;					// hard code color for 					feature = gffTabSplit[2];					//console.log(feature);					//within the region					if(n >= start && n <= end) {						gffRegion = gffTabSplit[2];						break;					}				}				if(gffRegion in gffColorKey){					color[n]=gffColorKey[gffRegion];				}else{					if(gffRegion!=''){						if(nextColorAvailable<numberOfDefaultColors){							// hard code for manuscript							if (feature == 'mature miRNA') {								gffColorKey[gffRegion]=defaultColors[0];							} else if (feature == 'star miRNA') {								gffColorKey[gffRegion]=defaultColors[1];							} else {								gffColorKey[gffRegion]=defaultColors[nextColorAvailable];								nextColorAvailable++;							}										color[n]=gffColorKey[gffRegion];						}else{							color[n]=gffColorKey["Other"];						}					}else{						//color[n]=gffColorKey["Unknown"];						color[n]=gffColorKey["Other"];					}				}			}		} // for 	} // else	//Begin, Adjust the size of display area.	var svgDoc=document.getElementById(id);	//Clear Element	svgDoc.childNodes=null;	svgDoc.children=null;	svgDoc.innerHTML="";	// Set attribute width & heitht of svgSS	// Max of the coordinate.	// Original width	var owidth=(Math.max.apply(Math,x)+30);			// Original height	var oheight=(Math.max.apply(Math,y)+20);		var scale=owidth/oheight;	svgDoc.setAttributeNS(null, "viewBox", "0 0 "+owidth+" "+oheight );	//2.7	if (scale>(8/3)){		svgDoc.setAttributeNS(null, "width", "1600" );		var h=Math.round(1600/scale);		svgDoc.setAttributeNS(null, "height", h );		svgDoc.setAttributeNS(null, "owidth", "1600" );		svgDoc.setAttributeNS(null, "oheight", h );	}else{		svgDoc.setAttributeNS(null, "height", "600" );		var w=Math.round(600*scale);		svgDoc.setAttributeNS(null, "width", w );		svgDoc.setAttributeNS(null, "oheight", "600" );		svgDoc.setAttributeNS(null, "owidth", w );	}	//End, Adjust the size of display area.	////////// Draw polyline(bond) in index order. //////////	var polyline = document.getElementById(svgns, "polyline");	// This object do not exixted.	if ( polyline == null ){ 		var polyline = document.createElementNS(svgns, "polyline");		svgDoc.appendChild(polyline);	}	var points = SecondStructure.coordinate;	// All of the separators should be replaced with space(" "), 	// if they are any character else.	// All separators are repalced with space(" ").	if ( separator != " " ){ 		points = points.replace( eval("/"+separator+"/g") ," ");	}	var style = "fill:none;stroke:rgb(0,123,123);stroke-width:2";	polyline.setAttributeNS(null, "id", "polyline"+0);	polyline.setAttributeNS(null, "points", points);	polyline.setAttributeNS(null, "style", style);	////////// Draw line(bond) for paired base. //////////	var pair = SecondStructure.pairings.split(separator);	for ( var i=0 ; i<pair.length ; ++i ){		var indexs = pair[i].split(",");		var line = document.getElementById(svgns, "line"+i);		if ( line == null ){			// This object do not exixted. 			var line = document.createElementNS(svgns, "line");			svgDoc.appendChild(line);		}		// pairing		line.setAttributeNS(null, "x1", x[ indexs[0]-1 ]);		line.setAttributeNS(null, "y1", y[ indexs[0]-1 ]);		line.setAttributeNS(null, "x2", x[ indexs[1]-1 ]);		line.setAttributeNS(null, "y2", y[ indexs[1]-1 ]);				var rgb;		switch ( elements[ indexs[0] ] ){		case "A":			rgb = "123,123,0";			break;		case "U":			if ( elements[ indexs[1] ] == "A" ){				rgb = "123,123,0";			}else{ 				// "G"				rgb = "123,255,123";			}                                			break;		case "G":			if ( elements[ indexs[1] ] == "C" ){				rgb = "0,123,123";			}else{ 				// "U"				rgb = "123,255,123";			}			break;		case "C":			rgb = "0,123,123";			break;		default :			rgb = "123,123,123";		}		var linestyle = "stroke:rgb("+rgb+");stroke-width:1";		line.setAttributeNS(null, "style", linestyle);	}	////////// Draw Bases. //////////	// The radius of Bases. According to the destance from v0 to v1.	var dv0v1;	dv0v1 = Math.sqrt( (x[1]-x[0])*(x[1]-x[0]) + (y[1]-y[0])*(y[1]-y[0]) )	dv0v1 = Math.round( dv0v1 );	var radius;	radius = dv0v1/3;	radius = Math.round( radius );		for (var i=0; i<x.length; ++i){		var circle = document.getElementById(svgns, "circle"+i);		if (i == 0 || i == x.length - 1) {			if ( circle == null ){				// This object do not exixted.				circle = document.createElementNS(svgns, "polygon");				svgDoc.appendChild(circle);			}			var locx = parseInt(x[i]), locy = parseInt(y[i]);			var points;			if (i == 0) {				// draw triangle				var r2 = radius * 2;				var x1 = locx;				var y1 = locy - r2;				var x2 = locx - Math.sqrt(3) / 2 * r2;				var y2 = locy + 0.5 * r2;				var x3 = locx + Math.sqrt(3) / 2 * r2;								var y3 = locy + 0.5 * r2;				var points = x1 + ',' + y1 + ' ' + x2 + ',' + y2 + ' ' + x3 + ',' + y3;			} else {				// draw square				var r2 = radius * 1.2;				var x1 = locx - r2;				var y1 = locy - r2;				var x2 = locx + r2;				var y2 = locy - r2				var x3 = locx + r2;				var y3 = locy + r2;				var x4 = locx - r2;				var y4 = locy + r2;				var points = x1 + ',' + y1 + ' ' + x2 + ',' + y2 + ' ' + x3 + ',' + y3 + ' ' + x4 + ',' + y4;			}						//console.log(points);			circle.setAttributeNS(null, "points", points);					} else {			// draw circle			if ( circle == null ){				// This object do not exixted.				circle = document.createElementNS(svgns, "circle");				svgDoc.appendChild(circle);			}			// Origin			circle.setAttributeNS(null, "cx", x[i]);			circle.setAttributeNS(null, "cy", y[i]);			// Radius (radius[i]=15;)			circle.setAttributeNS(null, "r", radius);		}		// Id & index		circle.setAttributeNS(null, "id", "circle"+i);		circle.setAttributeNS(null, "index", i);		circle.setAttributeNS(null, "stroke", "black");		circle.setAttributeNS(null, "stroke-width", "0");		// Set the color of every element with "RGB"		circle.setAttributeNS(null, "fill", color[i]);		// only for original graph		if (id == 'svgSS') {			// Add Event Listener to the circle.			//circle.addEventListener("click", getIndex, false);			circle.addEventListener('click', 				function(event) {					getIndex(event, SecondStructure.sequence.length);				},			false);		}		var text = document.getElementById(svgns, "text"+i);		if ( text == null ){			// This object do not exixted.			var text = document.createElementNS(svgns, "text");			svgDoc.appendChild(text);		}		// According the radius to set the text font size.		var textFontSize;		textFontSize = radius * 1.2;		text.setAttributeNS(null, "font-size", textFontSize);		text.setAttributeNS(null, "font-weight", "bold");		text.setAttributeNS(null, "id", "text"+i);		text.setAttributeNS(null, "index", i);		text.setAttributeNS(null, "x", parseInt(x[i])-5);		text.setAttributeNS(null, "y", parseInt(y[i])+5);		text.setAttributeNS(null, "fill", "black");		text.textContent = elements[i];		//Show the index of special elements.		if ( (i%10==9) || (i==0) || (i==(SecondStructure.sequence.length-1)) ){			text.textContent = text.textContent + (i+1);			// move x loc to left			text.setAttributeNS(null, "x", parseInt(x[i])-10);			//text.setAttributeNS(null, "font-size", radius * 1.1);		}		// Add Event Listener to the text.		//text.addEventListener("click", getIndex, false);		text.addEventListener('click', 			function(event) {				getIndex(event, SecondStructure.sequence.length);			},		false);	}	// show color key	var gffColorKeyBox=document.getElementById(ColorKey);	gffColorKeyBox.innerHTML="Color Key:<br>";	if(gffData == 'none'){		for(key in nucleotideColorKey){			gffColorKeyBox.innerHTML+="<div class='colorBlock' style='background: "+nucleotideColorKey[key]+"'></div><div class='keyText'>"+key+"</div>";		}	} else{		for(key in gffColorKey){			gffColorKeyBox.innerHTML+="<div class='colorBlock' style='background: "+gffColorKey[key]+"'></div><div class='keyText'>"+key+"</div>";		}	}} // function showSS()function textClick(textsequence, displayRulers, selected) {	if(textsequence.selectionStart == textsequence.selectionEnd) {		return;	}	if(displayRulers) {		//Rulers On		var indexSelectionStart = textToIndex(textsequence.selectionStart);		var indexSelectionEnd = textToIndex(textsequence.selectionEnd);	} else {		//Rulers Off		var indexSelectionStart = textsequence.selectionStart;		var indexSelectionEnd = textsequence.selectionEnd;	}	var max = textsequence.innerHTML.length;	signsSelected(indexSelectionStart, indexSelectionEnd, max);	elementsSelected(indexSelectionStart, indexSelectionEnd, max);	selected.start = indexSelectionStart+1;	selected.end = indexSelectionEnd;}//function textClick(evt)function remove_selected(len, selected) {	//Clear out current selected area	document.getElementById("sequence").selectionStart = 0;   	document.getElementById("sequence").selectionEnd = 0;   	//Clear out Dot Matrix Selection   	signsSelected(0,0, len);   	//Clear out SS Viewer Selection	elementsSelected(0,0, len);	selected.start = 0;	selected.end = 0;	// make sure reset	document.getElementById('selected_start').innerHTML = 0;	document.getElementById('selected_end').innerHTML = 0;}function getIndex(evt, len) {	var displayRulers = document.getElementById('showRulers').checked;	var start = document.getElementById('selected_start').innerHTML;	var end = document.getElementById('selected_end').innerHTML;	var target = evt.target;	var index = parseInt(target.getAttribute("index"));	var textsequence = document.getElementById("sequence");	if (evt.shiftKey)	{ // lift-click + shift		if (index < start - 1)		{			start = index + 1;		} else		{			end = index + 1;		}	} // Shift + lift-click	else	{ // lift-click		start = index + 1;		end = index + 1;	} 	if(displayRulers){		//Rulers On		textsequence.selectionEnd = indexToText(end, false);		textsequence.selectionStart = indexToText(start - 1, true);	} else{		//Rulers Off		textsequence.selectionEnd = end;		textsequence.selectionStart = start - 1;	}	var x = window.scrollX, y = window.scrollY;	textsequence.focus();	window.scrollTo(x, y);	document.getElementById('selected_start').innerHTML = start;	document.getElementById('selected_end').innerHTML = end;	signsSelected(start - 1, end, len);	elementsSelected(start - 1, end, len);}//function getIndex(evt)function signsSelected(start, end, max) {	for(n=0; n<start; ++n)	{ // Outside of the selection.		var rect = document.getElementById("rect"+n);		rect.setAttributeNS( null, "fill", "white" );		var text = document.getElementById("text"+n);		text.setAttributeNS( null, "fill", "black" );	} // for(n=0; n<start; ++n)	for(n=start; n<end; ++n)	{ // Inside of the selection.		var rect = document.getElementById("rect"+n);		rect.setAttributeNS( null, "fill", "#2894FF" );		var text = document.getElementById("text"+n);		text.setAttributeNS( null, "fill", "white" );	} // for(n=start; n<end; ++n)	for(n=end; n<max; ++n)	{ // Outside of the selection.		var rect = document.getElementById("rect"+n);		rect.setAttributeNS( null, "fill", "white" );		var text = document.getElementById("text"+n);		text.setAttributeNS( null, "fill", "black" );	} // for(n=end; n<max; ++n)}//function signsSelected(start,end)function elementsSelected(start, end, max) {	var selected = 3, notselected = 0;//1;	for(n=0; n<start; ++n)	{ // Outside of the selection.		var circle = document.getElementById("circle"+n);		circle.setAttributeNS( null, "stroke-width", notselected );	} // for(n=0; n<start; ++n)	for(n=start; n<end; ++n)	{ // Inside of the selection.		var circle = document.getElementById("circle"+n);		circle.setAttributeNS( null, "stroke-width", selected );	} // for(n=start; n<end; ++n)	for(n=end; n<max; ++n)	{ // Outside of the selection.		var circle = document.getElementById("circle"+n);		circle.setAttributeNS( null, "stroke-width", notselected );	} // for(n=end; n<max; ++n)}//function elementsSelected(start,end)function zoomin(id) {	var svgDoc=document.getElementById(id);	var width=svgDoc.getAttribute("width");	var height=svgDoc.getAttribute("height");	var owidth=svgDoc.getAttribute("owidth");	var oheight=svgDoc.getAttribute("oheight");	var nwidth=parseInt(width)+Math.round( 0.1*parseInt(owidth) );	var nheight=parseInt(height)+Math.round( 0.1*parseInt(oheight) );	svgDoc.setAttributeNS( null, "width", nwidth );	svgDoc.setAttributeNS( null, "height", nheight );} // function zoomin()function zoomout(id) {	var svgDoc=document.getElementById(id);	var width=svgDoc.getAttribute("width");	var height=svgDoc.getAttribute("height");	var owidth=svgDoc.getAttribute("owidth");	var oheight=svgDoc.getAttribute("oheight");	var nwidth=parseFloat(width)-Math.round( 0.1*parseFloat(owidth) );	var nheight=parseFloat(height)-Math.round( 0.1*parseFloat(oheight) );	if ( nwidth>0 && height>0)	{		svgDoc.setAttributeNS( null, "width", nwidth );		svgDoc.setAttributeNS( null, "height", nheight );	}	else	{ 		alert("This is the minimum size!");	}} // function zoomout()